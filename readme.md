- 【可直接运行】run_doom.py 用A2C训练上楼的NN
    - 命令行参数、示例
    
      - --env upfloor(用于训练上楼策略)
      - --ent 0.01(policy entrophy) 
      - --lr 1e-4 
      - --policy lstm 
      - --save_name upfloor512 (optional; default = --env) 
    
    - 代码中的一些参数
      - 继续训练: True 首次训练新模型请改为False
      - 并行游戏实例数: 16. 如果要跑测试请改小一点以便看清。
      - 输出模型(.dat)路径 请自行更改
      - 输入地图 由环境代码的种子范围决定，详见
    
    - 实现
      
        A2C的代码均为baselines库原封不动，无需细究其正确性。网络及初始化采用baselines库自带的代码，也是较为标准的实现。所以，仅说明环境的定义，详见下文。
    - 其他
      - Tensorflow 1.1.0 with GPU
      - Python 3.6.4
      - 使用的训练地图
      - 验证相关请见viz2018/doorandkey

- env/upfloor.py
    定义UpFloorEnv类，继承gym.core的Env。包含方法如下：
    - seed(self, seed=None)【重写的方法】
        - 输入:种子(无意义)
        - 输出:种子的列表(无意义)
    
        这个函数的本意是给本实例设置一个固定的游戏随机种子。但因为我们每隔一段时间(由ViZDoom的config文件设置)会重新加载一张随机地图， 实际上该函数没有用处。
    
    - step(self, action)【重写的方法】
        - 输入: 一个非负整数表示要执行的动作
        - 输出:
        环境执行动作后的状态。有四个值: 观测图像、Reward、是否Terminal、附加信息(一般为None)
        - Reward的计算:分为3个部分。
            - Z坐标之变化。 即上楼(高度提升)带来的奖励或下楼带来的惩罚。
            - 访问计数的倒数。
            将地图用50*50大小的方块进行 划分，访问计数全部初始化为1。若某一时刻落在一方块内，该方块的访问计数+1(但不超过10)；否则以0.98的系数衰减(但不低于1)。
            - '怼墙壁'惩罚。若深度值小于某个阈值，给予负1的惩罚，否则为0。
        - Reward的权重分配:
            三部分Reward的权重分配对训练结果有很大影响。Z坐标变化为训练目标，必须赋予足够大的权重。访问计数的倒数为了鼓励移动(包括从出生点开始寻找楼梯、以及上楼梯之后在高台上保持移动)。'怼墙壁'惩罚主要防止整个过程中太靠近墙体而挡住视野的情况。这里给出训练时采用的一组权重：
            - Z坐标的变化: 1.0
            - 访问计数的倒数: 0.05
            - '怼墙壁'惩罚: 0.05
        
        - Terminal的计算方法：
            很简单，直接返回DoomGame.is_episode_finished()方法，即在到达cfg文件设定的步数时认为本episode结束。因为地图上没有毒液/敌人，也没有开枪自杀的情况，不可能有因死亡导致游戏结束的情况。因为不适用USE按钮，也不可能有因激活出口导致游戏结束的情况。
            
    - reset(self)【重写的方法】
        - 输出:当前的观测画面
        
        本方法会在第一次step之前以及Terminal=True的step之后调用，主要进行地图的重置。先关闭游戏，然后在规定范围内生成一个随机数，并加载对应的wad文件。特别的是，由于很多地图出生点在一道门之后，所以人为定义了一个向前+开门动作通过这道门。这个动作与后续无关。此外，还需重置访问记录
        - 关于seed_min/seed_max
            这两个值限制了加载地图种子的范围，即[seed_min,seed_max)。均小于10000的会被认为是进行训练；均大于10000的会被认为是进行测试(在每步step后加入一个延时防止看不清)。如果需要测试指定地图如10000.wad，只需设置seed_min=seed_max-1=10000。

    - _reset_path_history(self)/_register_visit(self)
    
        这些方法定义了访问计数的更新方式。涉及的参数均在前面介绍过，此处就不再赘述。
    
    包含的属性如下:
    - observation_space【继承】：shape决定了观测矩阵的维度(长*宽*通道)
    - action_space【继承】: 决定了运动动作的个数。
    - available_actions: 为一list，Integer表示的动作到ViZDoom接收的类似One-hot的动作的映射。
    - seed_min/seed_max/wait_time 分为测试和训练两种配置，请根据需要自行更改。具体含义已进行过描述。


- 【可直接运行】anogenerator.py
    - 手动控制、自动存储图片+标注。对窗体点击鼠标，换下一张地图(编号+1)；空格键开门。
    - 需要加载修改过的地图和标记txt。这里提供1000张用于生成标记的地图（尽可能多地包含门和钥匙，但并不保证每一张），均为之前生成标记时没有用过的。下载链接 https://cloud.tsinghua.edu.cn/f/67d2016cea5c4fdc93c5/?dl=1
    - 运行前请设置地图路径、地图起止编号、生成图片及label路径、开始编号等。
    - 物体代号(地图标记txt文件中的，也是label中的):
      - 'reddoor' 0
      - 'bluedoor' 1
      - 'yellowdoor' 2
      - 'dooropen' 3
      - 'teleport' 4
      - 'exit' 5
      - 'redkey' 6
      - 'bluekey' 7
      - 'yellowkey' 8
    - 实现:
    有几个函数分别供不同的用途: genPos()生成正例、genNeg()生成负例(即画面中无   目标)、genVali()生成验证集(即无标注)。仅对功能最全的genPos()做说明。
    
        - 大体思路:从游戏地图预定义的若干个用户变量中读取是否能看到各个门。对所有能看见的门(钥匙)，计算其bounding_box，存储图片及标注。
        
        - 横向Bounding Box的计算：
        在mapPos2cameraPix函数中实现。先求目标边界点到正中视线的(点到直线)距离，然后使用该值+到目标边界点的距离(反正弦)计算张角。再用张角与当前分辨率下最大张角的比值(实际上是正切值的比值)计算目标边界点到画面正中央的距离占整个画面宽度的比例。最后换算成像素值。

        - 纵向Bounding Box的计算：
        在mapHeight2cameraPix函数中实现。首先，从横向的计算结果得出Agent到目标边界点在正中视线上投影的距离(即depth，从depth_buffer直接读取的话需要乘以一个系数)。然后根据上述值+垂直高差(反正切)计算张角。特别注意的是，GameVariable中读出的Agent的POS_Z是脚的位置，换算到眼睛位置需要+41。再用张角与当前分辨率下最大张角的比值(实际上是正切值的比值)计算目标边界点到画面正中央的距离占整个画面高度的比例。最后换算成像素值。
        
        - 后处理：
        由于游戏本身一些可见性判定的问题，会导致同一门的bounding_box被生成两次。为避免该问题，规定若新bounding_box与已有Box的重叠比例过大，则不被加入。
        
        - 钥匙的处理：
        钥匙可以直接从label_buffer读出，无需上述负责计算。
from vizdoom import *
from gym.core import Env
import math
from model.util import *
import time
from gym.spaces.discrete import Discrete
from gym.spaces.box import Box
import copy
from anogenerator import mapPos2cameraPix, mapHeight2cameraPix
from env.util import *


class FindDoorEnv(Env):
    def __init__(self):
        self.game = DoomGame()
        self.game.add_available_game_variable(GameVariable.POSITION_X)
        self.game.add_available_game_variable(GameVariable.POSITION_Y)
        self.game.add_available_game_variable(GameVariable.POSITION_Z)
        self.game.add_available_game_variable(GameVariable.ANGLE)
        self.game.set_labels_buffer_enabled(True)
        self.game.set_window_visible(True)

        self.observation_space = Box(low=0, high=255, shape=(256, 256, 1), dtype=np.uint8)
        self.action_space = Discrete(4)
        self.available_actions = np.eye(4).tolist()

    def seed(self, seed=None):
        seed += 16
        self.game.load_config('O:\\Doom\\viz_2018\\maps\\finddoor\\finddoor_flat.cfg')
        self.game.set_doom_scenario_path('O:\\Doom\\viz_2018\\maps\\finddoor\\finddoor_{}.wad'.format(seed))
        targets = open('O:\\Doom\\viz_2018\\maps\\finddoor\\target.txt')
        lines = targets.readlines()
        for l in lines:
            splited = l.replace('\n', '')
            splited = splited.split(' ')
            if int(splited[0]) == seed:
                self.x1, self.y1, self.x2, self.y2, self.zl, self.zh = [int(k) for k in splited[1:-1]]
                self.type = splited[-1]
                assert self.type in ['door', 'key', 'teleport', 'exit']
        targets.close()
        self.game.init()
        return [seed]

    def reset(self):
        #all_channel = np.concatenate(
        #    [self.game.get_state().screen_buffer, np.expand_dims(self._get_buffer_for_target(), 0)], axis=0)
        all_channel = np.expand_dims(self._get_buffer_for_target(), 0)
        return np.expand_dims(cv2.resize(all_channel.transpose([1, 2, 0]), (256, 256)), -1)

    def _get_buffer_for_target(self):
        '''
        :param i: generated by _get_visible_spot
        :return: extra buffer 480 x 640
        '''
        fordisp = np.zeros([480, 640], dtype=np.uint8)

        if self.type != 'key':
            pos_x = self.game.get_game_variable(GameVariable.POSITION_X)
            pos_y = self.game.get_game_variable(GameVariable.POSITION_Y)
            pos_z = self.game.get_game_variable(GameVariable.POSITION_Z)
            angle = self.game.get_game_variable(GameVariable.ANGLE)

            a_x, a_depth = mapPos2cameraPix(self.x1, self.y1, pos_x, pos_y, angle)
            b_x, b_depth = mapPos2cameraPix(self.x2, self.y2, pos_x, pos_y, angle)
            if a_x is None or b_x is None:
                a_x = b_x = a_y = b_y = 0
            else:
                a_y = max(mapHeight2cameraPix(self.zl, pos_z, a_depth),
                          mapHeight2cameraPix(self.zl, pos_z, b_depth))
                b_y = min(mapHeight2cameraPix(self.zh, pos_z, b_depth),
                          mapHeight2cameraPix(self.zh, pos_z, a_depth))
                if a_y <= b_y:
                    a_y = b_y = 0
            if self.type in ['exit','door']:
                fordisp[int(b_y):int(a_y), min(int(a_x), int(b_x)):max(int(a_x), int(b_x))] = 255
            else:
                fordisp[int(b_y):int(a_y), min(int(a_x), int(b_x)):max(int(a_x), int(b_x))] = 128

            return fordisp
        else:
            # look for keys
            labels = self.game.get_state().labels
            label_buffer = self.game.get_state().labels_buffer
            for l in labels:
                if (l.object_name == 'BlueCard') or \
                        (l.object_name == 'YellowCard') \
                        or (l.object_name == 'RedCard'):
                    y_pos, x_pos = np.where(label_buffer[:402, :] == l.value)
                    if len(x_pos) > 0 and np.max(y_pos) - np.min(y_pos) <= 130 and np.max(x_pos) - np.min(x_pos) <= 130:
                        fordisp[np.min(y_pos): np.max(y_pos), np.min(x_pos): np.max(x_pos)] = 255
                    return fordisp

        return fordisp

    def step(self, action):
        old_target_buff_sum = np.sum(self._get_buffer_for_target())
        rew = -0.008
        done = False

        pos_x = self.game.get_game_variable(GameVariable.POSITION_X)
        pos_y = self.game.get_game_variable(GameVariable.POSITION_Y)

        if (pos_x - self.x1) ** 2 + (pos_x - self.x2) ** 2 + (pos_y - self.y1) ** 2 + (pos_y - self.y2) ** 2 > 50000:
            self.game.make_action(self.available_actions[action], 4)

        elif self.type == 'key':
            old_key = checkKey(self.game.get_state().screen_buffer, 0) \
            or checkKey(self.game.get_state().screen_buffer, 1) \
            or checkKey(self.game.get_state().screen_buffer, 2)
            self.game.make_action(self.available_actions[action], 4)
            if self.game.is_episode_finished():
                done = True
                self.game.new_episode()

            new_key = checkKey(self.game.get_state().screen_buffer, 0) \
            or checkKey(self.game.get_state().screen_buffer, 1) \
            or checkKey(self.game.get_state().screen_buffer, 2)

            if (not old_key) and new_key:
                rew += 1
                done = True
                self.game.new_episode()

        elif self.type == 'teleport':
            self.game.make_action(self.available_actions[action], 4)
            if self.game.is_episode_finished():
                done = True
                self.game.new_episode()

            if checkTeleported(self.game.get_state().screen_buffer):
                rew += 1
                done = True

        #elif self.type == 'exit':
        #    self.game.make_action(self.available_actions[action])
        #    new_buff = self._get_buffer_for_target()
        #    if np.sum(new_buff) > np.sum(new_buff[1:401, 1:639]): #touch border
        #        rew -= 0.1

        #    if action == 3:
        #        if self.game.is_episode_finished():
        #            rew += 1.1
        #            done = True
        #            self.game.new_episode()

        else:
            if action == 3:
                self.game.make_action([0, 0, 1, 0], 8)
                new_buff = self._get_buffer_for_target()
                if np.sum(new_buff) > np.sum(new_buff[1:401, 1:639]):  # touch border
                    rew -= 0.1

                if self.game.is_episode_finished():
                    done = True
                    self.game.new_episode()
                else:
                    if self.type == 'door':
                        valid_use = attemptUse(self.game)
                    else:
                        self.game.make_action(self.available_actions[action])
                        valid_use = self.game.is_episode_finished()
                    if valid_use:
                        rew += 1
                        done = True
                        self.game.new_episode()
                    else:
                        rew -= 1
                        done = True
                        self.game.new_episode()

            else:
                self.game.make_action(self.available_actions[action], 4)
                if self.game.is_episode_finished():
                    done = True
                    self.game.new_episode()

        if self.game.is_episode_finished():
            self.game.new_episode()
            target_buff = np.zeros([480, 640])
            done = True
        else:
            target_buff = self._get_buffer_for_target()

            new_target_buff_sum = np.sum(target_buff)
            if new_target_buff_sum > 0:
                rew += 0.01
                rew += np.clip(new_target_buff_sum / old_target_buff_sum - 1, -0.1, 0.1)

        #all_channel = np.concatenate([self.game.get_state().screen_buffer, np.expand_dims(target_buff, axis=0)], axis=0)
        all_channel = np.expand_dims(target_buff, axis=0)
        return np.expand_dims(cv2.resize(all_channel.transpose([1, 2, 0]), (256, 256)), -1), rew, done, None


if __name__ == '__main__':
    env = FindDoorEnv()
    env.seed(0)
    obs = env.reset()
    while True:
        buffer = obs[:, :, 3]
        y_pos, x_pos = np.where(buffer > 0)
        x_mid = 0.5 * (min(x_pos) + max(x_pos))
        y_mid = 0.5 * (min(y_pos) + max(y_pos))
        x_min = min(x_pos)
        x_max = max(x_pos)
        if x_min < 66 and x_max > 190:
            obs, _, done, _ = env.step(4)
        elif x_max <= 120:
            obs, _, done, _ = env.step(0)  # l
        elif x_min >= 136:
            obs, _, done, _ = env.step(1)  # r
        else:
            obs, _, done, _ = env.step(2)
        if done:
            env.reset()
        time.sleep(0.5)
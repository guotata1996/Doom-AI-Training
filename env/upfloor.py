from vizdoom import *
from gym.core import Env
import math
from model.util import *
import time
from gym.spaces.discrete import Discrete
from gym.spaces.box import Box
from anogenerator import mapPos2cameraPix, mapHeight2cameraPix
from env.util import *

class UpFloorEnv(Env):
    def __init__(self):
        self.game = DoomGame()
        self.game.add_available_game_variable(GameVariable.POSITION_X)
        self.game.add_available_game_variable(GameVariable.POSITION_Y)
        self.game.add_available_game_variable(GameVariable.POSITION_Z)
        self.game.set_depth_buffer_enabled(True)
        self.observation_space = Box(low=0, high=255, shape=(84, 84, 3), dtype=np.uint8)
        self.action_space = Discrete(3)
        self.available_actions = np.eye(4).tolist()

        #train configuration

        self.seed_min = 0
        self.seed_max = 5000
        self.wait_time = 0

        #test configuration
        '''
        self.seed_min = 10009
        self.seed_max = 10010
        self.wait_time = 0.15
        '''

    def seed(self, seed=None):
        return [seed]

    def reset(self):
        self.game.close()
        seed = np.random.randint(self.seed_min, self.seed_max)
        self.game.load_config('O:\\Doom\\viz_2018\\maps\\finddoor\\finddoor.cfg')
        self.game.set_doom_scenario_path('O:\\Doom\\scenarios\\height\\{}.wad'.format(seed))

        self.game.init()

        if self.seed_min < 10000:
            #avoid door
            for _ in range(4):
                self.game.make_action([0,0,1,0], 4)
            self.game.make_action([0,0,0,1])
            for _ in range(8):
                self.game.make_action([0,0,1,0])

        self.start_x = self.game.get_game_variable(GameVariable.POSITION_X)
        self.start_y = self.game.get_game_variable(GameVariable.POSITION_Y)
        self._reset_path_history()
        return get_observation(self.game.get_state(), real_frame=True)

    def _get_buffer_for_target(self):
        '''
        :param i: generated by _get_visible_spot
        :return: extra buffer 480 x 640
        '''
        fordisp = np.zeros([480, 640], dtype=np.uint8)

        if self.type != 'key':
            pos_x = self.game.get_game_variable(GameVariable.POSITION_X)
            pos_y = self.game.get_game_variable(GameVariable.POSITION_Y)
            pos_z = self.game.get_game_variable(GameVariable.POSITION_Z)
            angle = self.game.get_game_variable(GameVariable.ANGLE)

            a_x, a_depth = mapPos2cameraPix(self.x1, self.y1, pos_x, pos_y, angle)
            b_x, b_depth = mapPos2cameraPix(self.x2, self.y2, pos_x, pos_y, angle)
            if a_x is None or b_x is None:
                a_x = b_x = a_y = b_y = 0
            else:
                a_y = max(mapHeight2cameraPix(self.zl, pos_z, a_depth),
                          mapHeight2cameraPix(self.zl, pos_z, b_depth))
                b_y = min(mapHeight2cameraPix(self.zh, pos_z, b_depth),
                          mapHeight2cameraPix(self.zh, pos_z, a_depth))
                if a_y <= b_y:
                    a_y = b_y = 0
            fordisp[int(b_y):int(a_y), min(int(a_x), int(b_x)):max(int(a_x), int(b_x))] = 255

            return fordisp
        else:
            #look for keys
            labels = self.game.get_state().labels
            label_buffer = self.game.get_state().labels_buffer
            for l in labels:
                if (l.object_name == 'BlueCard') or \
                        (l.object_name == 'YellowCard')\
                        or (l.object_name == 'RedCard'):
                    y_pos, x_pos = np.where(label_buffer[:402, :] == l.value)
                    if len(x_pos) > 0 and np.max(y_pos) - np.min(y_pos) <= 130 and np.max(x_pos) - np.min(x_pos) <= 130:
                        fordisp[np.min(y_pos): np.max(y_pos), np.min(x_pos): np.max(x_pos)] = 255
                    return fordisp

        return fordisp

    def step(self, action):
        if self.wait_time > 0:
            time.sleep(self.wait_time)

        old_x = self.game.get_game_variable(GameVariable.POSITION_X)
        old_y = self.game.get_game_variable(GameVariable.POSITION_Y)
        old_z = self.game.get_game_variable(GameVariable.POSITION_Z)
        self.game.make_action(self.available_actions[action], 4)
        new_x = self.game.get_game_variable(GameVariable.POSITION_X)
        new_y = self.game.get_game_variable(GameVariable.POSITION_Y)
        new_z = self.game.get_game_variable(GameVariable.POSITION_Z)

        if self.game.is_player_dead() or self.game.is_episode_finished():
            return get_observation(None), 0, True, None
        else:

            depth_buffer = self.game.get_state().depth_buffer.astype(np.int32)
            
            if np.sum(np.max(depth_buffer, axis=0)) < 1000:
                depth_rew = -1
            else:
                depth_rew = 0

            explore_rew = self._register_visit()
            height_rew = new_z - old_z
            speed_rew = math.sqrt((new_x - old_x)**2 + (new_y - old_y)**2) / 33
            #original:0.05,0,1,0.05
            #print(explore_rew, speed_rew, depth_rew)
            rew = 0.25 * explore_rew + 0.0 * speed_rew + height_rew + 0.05*depth_rew
            return get_observation(self.game.get_state(), real_frame=True), rew, False, None

    def _reset_path_history(self):
        self.path_history = np.ones([200,200], dtype=np.float32)

    def _register_visit(self):
        self.path_history = np.maximum(self.path_history * 0.98,1)
        pos_x = self.game.get_game_variable(GameVariable.POSITION_X)
        pos_y = self.game.get_game_variable(GameVariable.POSITION_Y)

        x_block = min(int(math.floor(pos_x)) // 50, 199)
        y_block = min(int(math.floor(pos_y)) // 50, 199)
        if self.path_history[x_block, y_block] < 10:
            self.path_history[x_block, y_block] += 1
        return 1 / float(self.path_history[x_block, y_block])